<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Academic Wheel of Privilege - Interactive Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --color-score-min: #ef4444;
            --color-score-mid: #eab308;
            --color-score-max: #22c55e;
            /* Category colors (used by JS for bubbles/buttons). Use slugified category names. */
            --cat-living-and-culture: #f472b6;
            --cat-caregiving: #a78bfa;
            --cat-education-and-career: #60a5fa;
            --cat-gender-and-sexuality: #fb923c;
            --cat-socioeconomic: #22d3d1;
            --cat-health-and-wellbeing: #4ade80;
            --cat-childhood-and-development: #fbbf24;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            overflow: hidden;
            color: #fff;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #info-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 380px;
            max-height: calc(100vh - 40px);
            background: rgba(15, 23, 42, 0.95);
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            opacity: 0;
            transform: translateX(20px);
            transition: all 0.3s ease;
            overflow-y: auto;
            z-index: 1000;
        }

        #info-panel.visible {
            opacity: 1;
            transform: translateX(0);
        }

        #info-panel h2 {
            font-size: 1.5rem;
            margin-bottom: 8px;
            color: #fff;
        }

        #info-panel .category-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 16px;
        }

        #info-panel .privilege-level {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 16px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        #info-panel .privilege-level .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        #info-panel .description {
            font-size: 0.95rem;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 16px;
        }

        #info-panel .uk-law {
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 16px;
        }

        #info-panel .uk-law h3 {
            font-size: 0.9rem;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #info-panel .uk-law p {
            font-size: 0.85rem;
            line-height: 1.5;
            color: rgba(255, 255, 255, 0.75);
        }

        #info-panel .uk-law.protected {
            background: rgba(34, 197, 94, 0.15);
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        #info-panel .uk-law.partial {
            background: rgba(234, 179, 8, 0.15);
            border: 1px solid rgba(234, 179, 8, 0.3);
        }

        #info-panel .uk-law.not-protected {
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        #info-panel .panel-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        #info-panel .nav-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: rgba(255, 255, 255, 0.8);
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        #info-panel .nav-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        #info-panel .nav-counter {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
        }

        #info-panel .spectrum {
            margin-top: 16px;
        }

        #info-panel .spectrum h3 {
            font-size: 0.9rem;
            margin-bottom: 12px;
            color: rgba(255, 255, 255, 0.9);
        }

        #info-panel .spectrum-items {
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }

        #info-panel .spectrum-item {
            flex: 1;
            padding: 10px 8px;
            border-radius: 8px;
            text-align: center;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        #info-panel .spectrum-item:hover {
            transform: scale(1.05);
        }

        #info-panel .spectrum-item.selected {
            box-shadow: 0 0 0 2px white;
        }

        #info-panel .spectrum-item.outer {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.4);
        }

        #info-panel .spectrum-item.middle {
            background: rgba(234, 179, 8, 0.2);
            border: 1px solid rgba(234, 179, 8, 0.4);
        }

        #info-panel .spectrum-item.inner {
            background: rgba(34, 197, 94, 0.2);
            border: 1px solid rgba(34, 197, 94, 0.4);
        }

        #header {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            max-width: 500px;
        }

        #header h1 {
            font-size: 1.8rem;
            margin-bottom: 8px;
            background: linear-gradient(90deg, var(--cat-education-and-career), var(--cat-caregiving), var(--cat-living-and-culture));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            white-space: nowrap;
        }

        #header p {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.5;
        }

        #score-panel {
            margin-top: 16px;
            padding: 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            text-align: center;
        }

        #score-panel .score-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--color-score-min);
            transition: color 0.3s ease;
        }

        #score-panel .score-label {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 4px;
        }

        #score-panel .score-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin-top: 8px;
            overflow: hidden;
            position: relative;
        }

        #score-panel .score-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
            -webkit-mask: linear-gradient(#fff 0 0);
            mask: linear-gradient(#fff 0 0);
        }

        #score-panel .score-fill::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(to right, var(--color-score-min), var(--color-score-mid), var(--color-score-max));
            border-radius: 3px;
        }

        #legend {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(15, 23, 42, 0.9);
            padding: 16px 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 100;
        }

        #legend h3 {
            font-size: 0.85rem;
            margin-bottom: 12px;
            color: rgba(255, 255, 255, 0.7);
        }

        #legend .legend-items {
            display: flex;
            gap: 16px;
        }

        #legend .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
        }

        #legend .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        #legend .legend-dot.inner { background: var(--color-score-max); }
        #legend .legend-dot.middle { background: var(--color-score-mid); }
        #legend .legend-dot.outer { background: var(--color-score-min); }

        #citation {
            position: fixed;
            bottom: 20px;
            right: 20px;
            max-width: 380px;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.4);
            line-height: 1.4;
            text-align: right;
            z-index: 100;
        }

        #citation a {
            color: rgba(96, 165, 250, 0.7);
            text-decoration: none;
        }

        #citation a:hover {
            text-decoration: underline;
        }

        #instructions {
            position: fixed;
            bottom: 110px;
            left: 32px;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            z-index: 100;
        }

        .category-filter {
            position: fixed;
            top: 180px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
        }

        .category-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 20px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.4;
            color: #000;
            font-weight: 500;
        }

        .category-btn:hover {
            opacity: 0.9;
            transform: scale(1.05);
            filter: brightness(1.2);
        }

        .category-btn.active {
            opacity: 1;
        }

        .category-btn:hover.active {
            transform: scale(1.05);
            filter: brightness(1.1);
        }

        .reset-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 20px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
            background: rgba(255, 255, 255, 0.05);
            margin-top: 12px;
        }

        .reset-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: scale(1.05);
        }

        .category-tooltip {
            position: fixed;
            background: rgba(15, 23, 42, 0.95);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 200;
            max-width: 280px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .category-tooltip.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .category-tooltip h4 {
            font-size: 1rem;
            margin-bottom: 8px;
            color: #fff;
        }

        .category-tooltip p {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .category-tooltip .items-list {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
        }

        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            #header {
                top: 12px;
                left: 50%;
                transform: translateX(-50%);
                text-align: center;
                max-width: calc(100% - 24px);
                width: 100%;
                padding: 0 12px;
            }

            #header h1 {
                font-size: 1.6rem;
                margin-bottom: 4px;
            }

            #header p {
                font-size: 0.75rem;
                line-height: 1.4;
            }

            #score-panel {
                margin-top: 12px;
                padding: 12px;
            }

            #score-panel .score-value {
                font-size: 1.8rem;
            }

            /* Attribution above category bar on mobile */
            #citation {
                display: block;
                position: fixed;
                bottom: 70px;
                left: 12px;
                right: 12px;
                max-width: none;
                text-align: center;
                font-size: 0.6rem;
                background: rgba(15, 23, 42, 0.9);
                padding: 8px 12px;
                border-radius: 8px;
                z-index: 99;
            }

            .category-filter {
                position: fixed;
                top: auto;
                bottom: 0;
                left: 0;
                right: 0;
                flex-direction: row;
                gap: 8px;
                padding: 12px 16px;
                background: rgba(15, 23, 42, 0.95);
                border-top: 1px solid rgba(255, 255, 255, 0.1);
                overflow-x: auto;
                justify-content: flex-start;
                -webkit-overflow-scrolling: touch;
                z-index: 100;
                /* Ensure touch events work */
                pointer-events: auto;
            }

            .category-btn {
                padding: 10px 16px;
                font-size: 0.75rem;
                white-space: nowrap;
                flex-shrink: 0;
                min-height: 44px;
                min-width: 44px;
                /* Ensure touch events work */
                pointer-events: auto;
                touch-action: manipulation;
            }

            .category-btn:hover, .category-btn.active {
                transform: none;
            }

            .reset-btn {
                padding: 10px 16px;
                font-size: 0.75rem;
                white-space: nowrap;
                flex-shrink: 0;
                margin-top: 0;
                margin-left: 8px;
                min-height: 44px;
                min-width: 44px;
                pointer-events: auto;
                touch-action: manipulation;
            }

            .reset-btn:hover {
                transform: none;
            }

            #info-panel {
                position: fixed;
                top: auto;
                bottom: 60px;
                left: 12px;
                right: 12px;
                width: auto;
                max-height: 50vh;
                border-radius: 16px 16px 0 0;
                transform: translateY(100%);
                padding: 20px;
                /* Scroll indicator - gradient fade at bottom */
                -webkit-mask-image: linear-gradient(to bottom, black calc(100% - 24px), transparent 100%);
                mask-image: linear-gradient(to bottom, black calc(100% - 24px), transparent 100%);
            }

            #info-panel::after {
                content: '';
                position: absolute;
                bottom: 0;
                left: 50%;
                transform: translateX(-50%);
                width: 40px;
                height: 4px;
                background: rgba(255, 255, 255, 0.3);
                border-radius: 2px;
                margin-bottom: 8px;
            }

            #info-panel.visible {
                transform: translateY(0);
            }

            #info-panel h2 {
                font-size: 1.2rem;
            }

            #info-panel .description {
                font-size: 0.85rem;
            }

            #info-panel .uk-law {
                padding: 12px;
            }

            #info-panel .uk-law p {
                font-size: 0.8rem;
            }

            #info-panel .spectrum-item {
                padding: 8px 4px;
                font-size: 0.65rem;
            }

            #legend {
                display: none;
            }

            #instructions {
                display: none;
            }

            /* Ensure container doesn't block category bar touch events */
            #container {
                pointer-events: auto;
            }
        }

        /* Very small screens */
        @media (max-width: 400px) {
            #header h1 {
                font-size: 1.4rem;
            }

            #header p {
                font-size: 0.7rem;
            }

            .category-btn {
                padding: 8px 14px;
                font-size: 0.7rem;
                min-height: 40px;
            }

            .reset-btn {
                padding: 8px 14px;
                font-size: 0.7rem;
                min-height: 40px;
            }

            #info-panel {
                padding: 16px;
                max-height: 45vh;
            }

            #info-panel h2 {
                font-size: 1.1rem;
            }

            #citation {
                font-size: 0.55rem;
                padding: 6px 10px;
            }
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <div id="header">
        <h1>Academic Wheel of Privilege</h1>
        <p>An interactive visualization exploring 20 identity types across 7 categories, showing how privilege intersects in academia.</p>
        <p>Click & drag bubbles and select positions on each spectrum.</p>
    </div>

    <div class="category-filter" id="category-filter"></div>

    <div class="category-tooltip" id="category-tooltip">
        <h4 id="tooltip-title"></h4>
        <p id="tooltip-description"></p>
        <div class="items-list" id="tooltip-items"></div>
    </div>

    <div id="info-panel">
        <div class="panel-nav" id="panel-nav">
            <button class="nav-btn" id="prev-btn">← Previous</button>
            <span class="nav-counter" id="nav-counter">1 / 20</span>
            <button class="nav-btn" id="next-btn">Next →</button>
        </div>
        <h2 id="panel-title">Select a bubble</h2>
        <div class="category-badge" id="panel-category"></div>
        <p class="description" id="panel-description"></p>
        <div class="uk-law" id="panel-uk-law">
            <h3><span id="uk-law-icon"></span> <span id="uk-law-title"></span></h3>
            <p id="uk-law-text"></p>
        </div>
        <div class="spectrum" id="panel-spectrum">
            <h3>Select your position (click to change ring)</h3>
            <div class="spectrum-items" id="spectrum-items"></div>
        </div>
        <div id="score-panel">
            <div class="score-value" id="score-value">60</div>
            <div class="score-label">Privilege Score (out of 60)</div>
            <div class="score-bar">
                <div class="score-fill" id="score-fill" style="width: 100%"></div>
            </div>
        </div>
    </div>

    <div id="legend">
        <h3>Privilege Level (drag bubbles between rings)</h3>
        <div class="legend-items">
            <div class="legend-item">
                <div class="legend-dot inner"></div>
                <span>Inner (3 pts) - Most Privileged</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot middle"></div>
                <span>Middle (2 pts)</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot outer"></div>
                <span>Outer (1 pt) - Least Privileged</span>
            </div>
        </div>
    </div>

    <div id="instructions">
        Drag bubbles between rings to set privilege | Click for details | Scroll to zoom
    </div>

    <div id="citation">
        Based on: <a href="https://ukrio.org/ukrio-resources/equality-diversity-and-inclusion/academic-wheel-of-privilege/" target="_blank">Academic Wheel of Privilege</a> (UKRIO Resource)<br> Elsherif, M. M., et al. (2022).
        Bridging Neurodiversity and Open Scholarship.<br>
        <a href="https://doi.org/10.31222/osf.io/k7a9p" target="_blank">https://doi.org/10.31222/osf.io/k7a9p</a><br>
        Adapted from Sylvia Duckworth's Wheel of Privilege <br>
        Visualisation by <a href="https://github.com/sjmf">@sjmf</a> at <a href="https://finnigan.dev/">finnigan.dev</a>
    </div>

    <script>
        // Configuration constants
        const CFG = {
            // Animation
            LERP: 0.1,
            FLOAT_SPEED: 0.001,
            FLOAT_AMPLITUDE: 0.1,

            // Scales
            DEFAULT_SCALE: 1,
            SELECTED_SCALE: 1.3,
            DRAG_SCALE: 1.3,
            DESELECTED_SCALE: 0.5,

            // Opacity
            SELECTED_OPACITY: 1.0,
            ACTIVE_OPACITY: 0.9,
            DESELECTED_OPACITY: 0.3,

            // Labels / canvas
            LABEL_CANVAS_W: 512,
            LABEL_CANVAS_H: 80,
            STATUS_CANVAS_H: 64,
            LABEL_FONT_SIZE: 32,
            NAME_LABEL_OFFSET_Y: -0.1,
            STATUS_LABEL_OFFSET_Y: 0.75,
            NAME_LABEL_SCALE: { x: 5, y: 0.8 },
            STATUS_LABEL_SCALE: { x: 4, y: 0.5 },

            // Camera
            CAMERA_Z_SMALL: 28,
            CAMERA_Z_MEDIUM: 24,
            CAMERA_Z_LARGE: 18,
            CAMERA_Z_MIN: 8,
            CAMERA_Z_MAX: 30,

            // Visuals
            GLOW_OPACITY: 0.2,
            GLOW_HIGHLIGHT_OPACITY: 0.4
        ,
            // Geometry and interaction defaults
            RING_TUBE: 0.05,
            RING_RADIAL_SEGMENTS: 16,
            RING_TUBULAR_SEGMENTS: 100,
            BUBBLE_RADIUS: 0.45,
            BUBBLE_SEGMENTS: { width: 32, height: 32 },
            GLOW_RADIUS: 0.5,
            GLOW_SEGMENTS: { width: 32, height: 32 },
            RING_PADDING: 1,

            // Interaction tuning
            ROTATION_DAMPING: 0.95,
            ROTATION_SENSITIVITY: 0.005,
            ZOOM_SENSITIVITY: 0.01,
            HOVER_SCALE: 1.2,

            // Camera params
            CAMERA_FOV: 60,
            CAMERA_NEAR: 0.1,
            CAMERA_FAR: 1000,
            INIT_ROT_X: Math.PI - Math.PI / 8,

            // Auto-rotation thresholds
            AUTO_ROTATE_THRESHOLD: 0.001,
            AUTO_ROTATE_AMOUNT: 0.0005,

            // Projection Z used when converting mouse to world coordinates
            PROJECTION_Z: 0.5,

            // Mobile-specific settings
            MOBILE_PANEL_OFFSET_Y: 3,  // How much to move wheel up when panel opens
            TOUCH_ZOOM_SENSITIVITY: 0.03,
            TOUCH_ROTATION_SENSITIVITY: 0.008
        };

        // Data for all 20 identity types
        const identityData = {
            // Category: Living and Culture
            "Skin Color": {
                category: "Living and Culture",
                spectrum: { outer: "Dark", middle: "Various shades", inner: "White" },
                description: "Skin color affects how individuals are perceived and treated in academic and social settings. Lighter skin tones are often associated with greater privilege in Western academic contexts.",
                ukLaw: {
                    status: "protected",
                    title: "Protected Characteristic",
                    text: "Race, including skin color, is a protected characteristic under the Equality Act 2010. Discrimination based on skin color is unlawful in employment, education, and services."
                }
            },
            "Religion and Culture": {
                category: "Living and Culture",
                spectrum: { outer: "Not widely accepted", middle: "Usually accepted", inner: "Widely accepted" },
                description: "Religious and cultural backgrounds influence access to academic networks, understanding of hidden curricula, and ability to participate fully in academic life.",
                ukLaw: {
                    status: "protected",
                    title: "Protected Characteristic",
                    text: "Religion or belief is a protected characteristic under the Equality Act 2010. This includes religious and philosophical beliefs, as well as lack of belief."
                }
            },
            "Citizenship": {
                category: "Living and Culture",
                spectrum: { outer: "Undocumented", middle: "Documented", inner: "Citizen" },
                description: "Citizenship status affects access to funding, employment opportunities, and the ability to participate freely in academic activities without visa restrictions.",
                ukLaw: {
                    status: "partial",
                    title: "Partial Protection",
                    text: "While nationality is a protected characteristic, immigration status itself is not directly protected. However, indirect discrimination based on nationality may be unlawful."
                }
            },
            "Language": {
                category: "Living and Culture",
                spectrum: { outer: "Non-English monolingual", middle: "Learned English", inner: "Native English" },
                description: "English language proficiency significantly impacts academic success, publication opportunities, and networking in predominantly Anglophone academic environments.",
                ukLaw: {
                    status: "partial",
                    title: "Indirect Protection",
                    text: "Language is not a protected characteristic, but discrimination based on language may constitute indirect race discrimination if it disproportionately affects certain ethnic groups."
                }
            },

            // Category: Caregiving
            "Caring Duties": {
                category: "Caregiving",
                spectrum: { outer: "Sole carer", middle: "Shared care", inner: "No care duties" },
                description: "Caring responsibilities for children, elderly relatives, or others significantly impact time available for research, networking, and career advancement.",
                ukLaw: {
                    status: "partial",
                    title: "Indirect Protection",
                    text: "While caring duties aren't directly protected, discrimination against carers may constitute indirect sex discrimination (as women disproportionately bear caring responsibilities) under the Equality Act 2010."
                }
            },

            // Category: Education and Career
            "Caregiver Educational Level": {
                category: "Education and Career",
                spectrum: { outer: "Primary/Secondary", middle: "Tertiary", inner: "Advanced degrees" },
                description: "Parents' or caregivers' educational background influences cultural capital, understanding of academic systems, and access to guidance and networks.",
                ukLaw: {
                    status: "not-protected",
                    title: "Not Directly Protected",
                    text: "Parental education level is not a protected characteristic. However, it relates to socioeconomic background, which the Equality Act 2010 does not directly cover."
                }
            },
            "Formal Education": {
                category: "Education and Career",
                spectrum: { outer: "None", middle: "Limited", inner: "Degree(s)" },
                description: "Level of formal education affects access to academic positions, credibility in scholarly discussions, and ability to navigate academic institutions.",
                ukLaw: {
                    status: "not-protected",
                    title: "Not Directly Protected",
                    text: "Educational qualifications are not a protected characteristic. Requiring qualifications is generally lawful if justified for the role."
                }
            },
            "Funding/Resources": {
                category: "Education and Career",
                spectrum: { outer: "None/Very low", middle: "Medium", inner: "High" },
                description: "Access to research funding and institutional resources determines capacity to conduct research, attend conferences, and publish in prestigious venues.",
                ukLaw: {
                    status: "not-protected",
                    title: "Not Directly Protected",
                    text: "Access to funding is not a protected characteristic, though funding disparities may intersect with protected characteristics like race or disability."
                }
            },
            "Career Stage": {
                category: "Education and Career",
                spectrum: { outer: "Early career", middle: "Mid-career", inner: "Late career/Tenured" },
                description: "Career stage affects job security, influence in academic decisions, and access to resources and networks that support career advancement.",
                ukLaw: {
                    status: "protected",
                    title: "Related to Age Protection",
                    text: "Age is a protected characteristic under the Equality Act 2010. Career stage discrimination may constitute age discrimination if it disproportionately affects certain age groups."
                }
            },
            "Institution": {
                category: "Education and Career",
                spectrum: { outer: "Teaching intensive", middle: "Equal teaching/research", inner: "Research intensive" },
                description: "Type of institution affects time for research, access to funding, prestige, and career progression opportunities in academia.",
                ukLaw: {
                    status: "not-protected",
                    title: "Not Directly Protected",
                    text: "Institutional type is not a protected characteristic. However, institutional prestige hierarchies may reinforce existing inequalities."
                }
            },

            // Category: Gender and Sexuality
            "Gender": {
                category: "Gender and Sexuality",
                spectrum: { outer: "Trans/Non-binary/Intersex", middle: "Cis woman", inner: "Cis man" },
                description: "Gender identity and expression affect experiences of discrimination, access to opportunities, and representation in academic leadership positions.",
                ukLaw: {
                    status: "protected",
                    title: "Protected Characteristics",
                    text: "Sex and gender reassignment are protected characteristics under the Equality Act 2010. This protects against discrimination based on being male, female, or undergoing gender transition."
                }
            },
            "Sexuality": {
                category: "Gender and Sexuality",
                spectrum: { outer: "Lesbian/Bi/Pan/Asexual", middle: "Gay man", inner: "Heterosexual" },
                description: "Sexual orientation influences experiences of inclusion or exclusion in academic environments and can affect career progression and wellbeing.",
                ukLaw: {
                    status: "protected",
                    title: "Protected Characteristic",
                    text: "Sexual orientation is a protected characteristic under the Equality Act 2010. Discrimination based on being lesbian, gay, bisexual, or heterosexual is unlawful."
                }
            },

            // Category: Race
            "Current Wealth": {
                category: "Socioeconomic",
                spectrum: { outer: "Poor", middle: "Middle class", inner: "Rich" },
                description: "Current wealth affects ability to access education, take unpaid opportunities, relocate for positions, and weather periods of job insecurity.",
                ukLaw: {
                    status: "not-protected",
                    title: "Not Directly Protected",
                    text: "Socioeconomic status is not a protected characteristic under the Equality Act 2010, though the Public Sector Equality Duty includes consideration of socioeconomic disadvantage in some contexts."
                }
            },
            "Housing": {
                category: "Socioeconomic",
                spectrum: { outer: "Homeless", middle: "Renting", inner: "Owns property" },
                description: "Housing stability affects ability to focus on academic work, access to quiet study spaces, and financial security needed for career risk-taking.",
                ukLaw: {
                    status: "not-protected",
                    title: "Not Directly Protected",
                    text: "Housing status is not a protected characteristic. However, housing discrimination may intersect with protected characteristics like race or disability."
                }
            },

            // Category: Health and Wellbeing
            "Neurodiversity": {
                category: "Health and Wellbeing",
                spectrum: { outer: "Multiply neurodivergent", middle: "Some neurodivergence", inner: "Neurotypical" },
                description: "Neurodivergent individuals (autism, ADHD, dyslexia, etc.) face unique challenges in academic environments designed for neurotypical people, including sensory issues and executive function demands.",
                ukLaw: {
                    status: "protected",
                    title: "Protected Under Disability",
                    text: "Neurodevelopmental conditions that have a substantial and long-term adverse effect on ability to carry out normal day-to-day activities are protected as disabilities under the Equality Act 2010."
                }
            },
            "Mental Health": {
                category: "Health and Wellbeing",
                spectrum: { outer: "Vulnerable", middle: "Mostly stable", inner: "Robust" },
                description: "Mental health affects capacity to manage academic pressures, maintain productivity, and navigate competitive and often stressful academic environments.",
                ukLaw: {
                    status: "protected",
                    title: "Protected Under Disability",
                    text: "Mental health conditions that have a substantial and long-term adverse effect on day-to-day activities are protected as disabilities under the Equality Act 2010."
                }
            },
            "Disability": {
                category: "Health and Wellbeing",
                spectrum: { outer: "Multiply disabled", middle: "Some disability", inner: "Able-bodied" },
                description: "Physical disabilities affect access to academic spaces, travel for conferences, and ability to perform certain research tasks without accommodations.",
                ukLaw: {
                    status: "protected",
                    title: "Protected Characteristic",
                    text: "Disability is a protected characteristic under the Equality Act 2010. Employers and institutions have a duty to make reasonable adjustments for disabled individuals."
                }
            },
            "Body Size": {
                category: "Health and Wellbeing",
                spectrum: { outer: "Large", middle: "Average", inner: "Slim" },
                description: "Body size affects how individuals are perceived professionally, can influence hiring decisions, and impacts experiences of belonging in academic settings.",
                ukLaw: {
                    status: "not-protected",
                    title: "Not Directly Protected",
                    text: "Body size or weight is not a protected characteristic under the Equality Act 2010. However, obesity may be considered a disability in some cases if it meets the legal definition."
                }
            },

            // Category: Childhood and Development
            "Childhood Household Wealth": {
                category: "Childhood and Development",
                spectrum: { outer: "Poor", middle: "Middle class", inner: "Rich" },
                description: "Childhood socioeconomic status affects educational opportunities, cultural capital, and networks that influence later academic success.",
                ukLaw: {
                    status: "not-protected",
                    title: "Not Directly Protected",
                    text: "Childhood socioeconomic background is not a protected characteristic, though it significantly influences life outcomes and intersects with protected characteristics."
                }
            },
            "Childhood Household Stability": {
                category: "Childhood and Development",
                spectrum: { outer: "Unstable", middle: "Mostly stable", inner: "Stable" },
                description: "Childhood stability affects attachment, mental health, and ability to develop skills and networks that support academic success.",
                ukLaw: {
                    status: "not-protected",
                    title: "Not Directly Protected",
                    text: "Childhood experiences are not protected characteristics, though adverse childhood experiences may result in conditions that are protected as disabilities."
                }
            }
        };

        // Category colors, positions, and descriptions
        // Colors based on original Wheel of Privilege diagram
        const categories = {
            "Living and Culture": {
                angle: 0,
                description: "Factors related to cultural background, identity, and lived experience in society."
            },
            "Caregiving": {
                angle: 51.4,
                description: "Responsibilities for caring for others that can impact time and energy available for academic work."
            },
            "Education and Career": {
                angle: 102.8,
                description: "Formal educational background, career stage, and access to academic resources and networks."
            },
            "Gender and Sexuality": {
                angle: 154.2,
                description: "Gender identity and sexual orientation, which affect representation and experiences in academia."
            },
            "Socioeconomic": {
                angle: 205.6,
                description: "Current financial status and access to material resources that enable academic participation."
            },
            "Health and Wellbeing": {
                angle: 257,
                description: "Physical and mental health factors that affect ability to participate fully in academic life."
            },
            "Childhood and Development": {
                angle: 308.4,
                description: "Early life experiences that shape educational opportunities and cultural capital."
            }
        };

        // Ring radii - inner is most privileged (1.5 unit spacing)
        const ringRadii = { inner: 4.0, middle: 5.5, outer: 7.0 };
        const ringPoints = { inner: 3, middle: 2, outer: 1 };

        // Scene setup
        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(CFG.CAMERA_FOV, window.innerWidth / window.innerHeight, CFG.CAMERA_NEAR, CFG.CAMERA_FAR);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // Function to calculate optimal camera distance based on screen size
        function getOptimalCameraZ() {
            const width = window.innerWidth;

            // On mobile/small screens, zoom out more to fit the wheel
            if (width <= 480) {
                return CFG.CAMERA_Z_SMALL;
            } else if (width <= 768) {
                return CFG.CAMERA_Z_MEDIUM;
            } else {
                return CFG.CAMERA_Z_LARGE;
            }
        }

        camera.position.z = getOptimalCameraZ() * 0.9; // Slight zoom in

        // Utility: slugify category names for CSS var lookup
        function slugify(name) {
            return name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
        }

        // Read category color from CSS custom properties (fallback to categories map)
        function getCategoryColor(categoryName) {
            try {
                const root = document.documentElement;
                const varName = '--cat-' + slugify(categoryName);
                const v = getComputedStyle(root).getPropertyValue(varName).trim();
                if (v) return v;
            } catch (e) {
                // ignore
            }
            return (categories[categoryName] && categories[categoryName].color) || '#999999';
        }

        // Set initial rotation
        scene.rotation.x = CFG.INIT_ROT_X;

        // Raycaster for hover detection
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Store bubble meshes
        const bubbles = [];
        let hoveredBubble = null;
        let lockedBubble = null;
        let isDragging = false;
        let isDraggingBubble = false;
        let draggedBubble = null;
        let previousMousePosition = { x: 0, y: 0 };
        let rotationVelocity = { x: 0, y: 0 };
        let dragRadiusOffset = 0; // Offset between click point and bubble center radius

        // Create concentric rings
        // Read ring colors from CSS variables so theme can be driven from CSS.
        (function() {
            // Use shared helper to parse CSS vars into RGB objects
            const { minRgb, midRgb, maxRgb } = getScoreRGBs();
            const rgbToNum = ({ r, g, b }) => (r << 16) + (g << 8) + b;

            // inner should be the "max" (most privileged), middle the mid, outer the min
            window.ringColors = {
                inner: rgbToNum(maxRgb),
                middle: rgbToNum(midRgb),
                outer: rgbToNum(minRgb)
            };
        })();
        Object.entries(ringRadii).forEach(([name, radius]) => {
            const ringGeometry = new THREE.TorusGeometry(radius, CFG.RING_TUBE, CFG.RING_RADIAL_SEGMENTS, CFG.RING_TUBULAR_SEGMENTS);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: ringColors[name],
                transparent: true,
                opacity: 0.5
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.userData.ringName = name;
            scene.add(ring);
        });

        // Create text sprite
        function createTextSprite(text, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = CFG.LABEL_CANVAS_W;
            canvas.height = CFG.LABEL_CANVAS_H;

            context.fillStyle = 'transparent';
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Measure text and adjust font size if needed
            let fontSize = CFG.LABEL_FONT_SIZE;
            context.font = `bold ${fontSize}px Segoe UI, sans-serif`;
            let textWidth = context.measureText(text).width;

            // Scale down font if text is too wide (leave 20px padding)
            const maxWidth = canvas.width - 20;
            if (textWidth > maxWidth) {
                fontSize = Math.floor(fontSize * (maxWidth / textWidth));
                context.font = `bold ${fontSize}px Segoe UI, sans-serif`;
            }

            context.textAlign = 'center';
            context.textBaseline = 'middle'; 

            // Text shadow for readability
            context.fillStyle = 'rgba(0,0,0,0.8)';
            context.fillText(text, canvas.width / 2 + 1, canvas.height / 2 + 1);

            context.fillStyle = '#ffffff';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false,
                depthWrite: false
            });

            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(CFG.NAME_LABEL_SCALE.x, CFG.NAME_LABEL_SCALE.y, 1); // Larger sprite for bigger font
            sprite.renderOrder = 999;

            return sprite;
        }

        // Create bubble with label
        // globalIndex is used to equally space all 20 bubbles
        function createBubble(name, data, globalIndex, totalBubbles) {
            const categoryInfo = categories[data.category];
            const categoryColor = getCategoryColor(data.category);
            // Equally space all bubbles: 360° / 20 = 18° each
            const angle = (globalIndex / totalBubbles) * Math.PI * 2;

            // All bubbles start on inner ring (most privileged)
            const radius = ringRadii.inner;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;

            const geometry = new THREE.SphereGeometry(CFG.BUBBLE_RADIUS, CFG.BUBBLE_SEGMENTS.width, CFG.BUBBLE_SEGMENTS.height);
            const material = new THREE.MeshPhongMaterial({
                color: new THREE.Color(categoryColor),
                transparent: true,
                opacity: CFG.ACTIVE_OPACITY,
                shininess: 100,
                emissive: new THREE.Color(categoryColor),
                emissiveIntensity: 0.15
            });

            const bubble = new THREE.Mesh(geometry, material);
            bubble.position.set(x, y, 0);
            bubble.userData = {
                name,
                ...data,
                angle,
                currentRing: 'inner',
                points: 3,
                targetScale: CFG.DEFAULT_SCALE,
                targetOpacity: CFG.ACTIVE_OPACITY,
                isDeselected: false,
                targetPosition: { x, y, z: 0 }
            };

            // Add glow
            const glowGeometry = new THREE.SphereGeometry(CFG.GLOW_RADIUS, CFG.GLOW_SEGMENTS.width, CFG.GLOW_SEGMENTS.height);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color(categoryColor),
                transparent: true,
                opacity: CFG.GLOW_OPACITY
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            bubble.add(glow);
            bubble.userData.glow = glow;

            // Add text label (name of category on bubble)
            const label = createTextSprite(name, categoryColor);
            label.position.set(0, CFG.NAME_LABEL_OFFSET_Y, 0);
            bubble.add(label);
            bubble.userData.label = label;
            bubble.userData.labelLocalPos = { x: 0, y: CFG.NAME_LABEL_OFFSET_Y, z: 0 };

            // Add status label (current position below bubble)
            const statusLabel = createTextSprite(data.spectrum.inner, categoryColor);
            statusLabel.position.set(0, CFG.STATUS_LABEL_OFFSET_Y, 0);
            statusLabel.scale.set(CFG.STATUS_LABEL_SCALE.x, CFG.STATUS_LABEL_SCALE.y, 1); // Slightly smaller than name label
            bubble.add(statusLabel);
            bubble.userData.statusLabel = statusLabel;
            bubble.userData.statusLabelLocalPos = { x: 0, y: 0.75, z: 0 };

            scene.add(bubble);
            bubbles.push(bubble);

            return bubble;
        }

        // Create all bubbles with equal spacing
        const allIdentities = Object.entries(identityData);
        const totalBubbles = allIdentities.length;

        // Sort by category to keep category grouping, then create with equal angular spacing
        const categoryOrder = Object.keys(categories);
        allIdentities.sort((a, b) => {
            const catAIndex = categoryOrder.indexOf(a[1].category);
            const catBIndex = categoryOrder.indexOf(b[1].category);
            return catAIndex - catBIndex;
        });

        allIdentities.forEach(([name, data], globalIndex) => {
            createBubble(name, data, globalIndex, totalBubbles);
        });

        // Create category filter buttons with tooltip
        const filterContainer = document.getElementById('category-filter');
        const tooltip = document.getElementById('category-tooltip');
        const tooltipTitle = document.getElementById('tooltip-title');
        const tooltipDescription = document.getElementById('tooltip-description');
        const tooltipItems = document.getElementById('tooltip-items');
        const categoryButtons = {}; // Store buttons by category name for state management

        function showCategoryTooltip(name, info, btn) {
            tooltipTitle.textContent = name;
            tooltipTitle.style.color = getCategoryColor(name);
            tooltipDescription.textContent = info.description;

            // Get items in this category
            const items = Object.keys(identityData).filter(k => identityData[k].category === name);
            tooltipItems.textContent = 'Includes: ' + items.join(', ');

            // Position tooltip
            const rect = btn.getBoundingClientRect();
            tooltip.style.left = (rect.right + 10) + 'px';
            tooltip.style.top = rect.top + 'px';

            tooltip.classList.add('visible');
        }

        function hideCategoryTooltip() {
            tooltip.classList.remove('visible');
        }

        Object.entries(categories).forEach(([name, info]) => {
            const btn = document.createElement('button');
            btn.className = 'category-btn active';
            btn.style.backgroundColor = getCategoryColor(name);
            btn.textContent = name;
            categoryButtons[name] = btn; // Store button reference

            // Click to toggle visibility
            btn.addEventListener('click', () => {
                btn.classList.toggle('active');
                const isActive = btn.classList.contains('active');
                bubbles.forEach(bubble => {
                    if (bubble.userData.category === name) {
                        bubble.userData.isDeselected = !isActive;
                        bubble.userData.targetOpacity = isActive ? CFG.ACTIVE_OPACITY : CFG.DESELECTED_OPACITY;
                        bubble.userData.targetScale = isActive ? CFG.DEFAULT_SCALE : CFG.DESELECTED_SCALE;
                        
                        // If deselecting and this bubble is locked, unlock it
                        if (!isActive && lockedBubble === bubble) {
                            lockedBubble = null;
                            hideInfoPanel();
                        }
                    }
                });
                updateUrlHash(); // Persist category state to URL
            });

            // Hover to show tooltip
            btn.addEventListener('mouseenter', () => showCategoryTooltip(name, info, btn));
            btn.addEventListener('mouseleave', hideCategoryTooltip);

            filterContainer.appendChild(btn);
        });

        // Create reset button after category buttons
        const resetBtn = document.createElement('button');
        resetBtn.className = 'reset-btn';
        resetBtn.id = 'reset-btn';
        resetBtn.textContent = 'Reset All';
        filterContainer.appendChild(resetBtn);

        // Reset button handler
        resetBtn.addEventListener('click', () => {
            // Reset all bubbles to inner ring
            bubbles.forEach(bubble => {
                moveBubbleToRing(bubble, 'inner');
            });
            
            // Activate all categories
            Object.entries(categories).forEach(([name, _]) => {
                const btn = categoryButtons[name];
                if (!btn.classList.contains('active')) {
                    btn.classList.add('active');
                }
                // Update all bubbles in this category
                bubbles.forEach(bubble => {
                        if (bubble.userData.category === name) {
                            bubble.userData.isDeselected = false;
                            bubble.userData.targetOpacity = CFG.ACTIVE_OPACITY;
                            bubble.userData.targetScale = CFG.DEFAULT_SCALE;
                        }
                });
            });
            
            // Unlock any locked bubble and hide panel
            if (lockedBubble) {
                lockedBubble = null;
                hideInfoPanel();
            }
            
            updateUrlHash();
        });

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 0.8, 100);
        pointLight.position.set(10, 10, 15);
        scene.add(pointLight);
        const pointLight2 = new THREE.PointLight(0x60a5fa, 0.4, 100);
        pointLight2.position.set(-10, -10, 10);
        scene.add(pointLight2);

        // Utility functions for color conversion
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }
        
        // Read CSS score color variables and return parsed RGB objects.
        // Keeps defaults if variables are missing.
        function getScoreRGBs() {
            const root = document.documentElement;
            const colorMin = getComputedStyle(root).getPropertyValue('--color-score-min').trim();
            const colorMid = getComputedStyle(root).getPropertyValue('--color-score-mid').trim();
            const colorMax = getComputedStyle(root).getPropertyValue('--color-score-max').trim();

            const minRgb = hexToRgb(colorMin) || { r: 239, g: 68, b: 68 };
            const midRgb = hexToRgb(colorMid) || { r: 234, g: 179, b: 8 };
            const maxRgb = hexToRgb(colorMax) || { r: 34, g: 197, b: 94 };

            return { minRgb, midRgb, maxRgb };
        }
        
        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => {
                const hex = Math.round(x).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('');
        }

        // Return a hex color for a normalized score (0..1) using CSS variables
        function getScoreColor(normalizedScore) {
            const { minRgb: rgb1, midRgb: rgb2, maxRgb: rgb3 } = getScoreRGBs();

            if (normalizedScore <= 0.5) {
                const t = normalizedScore * 2;
                const r = rgb1.r + (rgb2.r - rgb1.r) * t;
                const g = rgb1.g + (rgb2.g - rgb1.g) * t;
                const b = rgb1.b + (rgb2.b - rgb1.b) * t;
                return rgbToHex(r, g, b);
            } else {
                const t = (normalizedScore - 0.5) * 2;
                const r = rgb2.r + (rgb3.r - rgb2.r) * t;
                const g = rgb2.g + (rgb3.g - rgb2.g) * t;
                const b = rgb2.b + (rgb3.b - rgb2.b) * t;
                return rgbToHex(r, g, b);
            }
        }

        // Calculate and update score
        function updateScore() {
            let total = 0;
            bubbles.forEach(b => {
                total += b.userData.points;
            });
            const minScore = bubbles.length * 1; // 20 (all outer ring)
            const maxScore = bubbles.length * 3; // 60 (all inner ring)
            document.getElementById('score-value').textContent = total;
            
            // Normalize: 20 = 0%, 60 = 100%
            const percentage = ((total - minScore) / (maxScore - minScore)) * 100;
            document.getElementById('score-fill').style.width = percentage + '%';
            const normalizedScore = (total - minScore) / (maxScore - minScore); // 0 to 1
            document.getElementById('score-value').style.color = getScoreColor(normalizedScore);
        }

        // Update status label sprite texture
        // This is the label that changes on privilege level
        function updateStatusLabel(bubble, text) {
            if (!bubble.userData.statusLabel) return;

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = CFG.LABEL_CANVAS_W;
            canvas.height = CFG.STATUS_CANVAS_H;

            context.fillStyle = 'transparent';
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Measure and adjust font size for long text
            let fontSize = CFG.LABEL_FONT_SIZE;
            context.font = `bold ${fontSize}px Segoe UI, sans-serif`;
            let textWidth = context.measureText(text).width;
            const maxWidth = canvas.width - 20;
            if (textWidth > maxWidth) {
                fontSize = Math.floor(fontSize * (maxWidth / textWidth));
                context.font = `bold ${fontSize}px Segoe UI, sans-serif`;
            }

            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillStyle = 'rgba(0,0,0,0.8)';
            context.fillText(text, canvas.width / 2 + 1, canvas.height / 2 + 1);
            context.fillStyle = 'rgba(255,255,255,0.9)';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            // Safely dispose of old texture if it exists
            if (bubble.userData.statusLabel.material.map) {
                bubble.userData.statusLabel.material.map.dispose();
            }
            bubble.userData.statusLabel.material.map = texture;
            bubble.userData.statusLabel.material.needsUpdate = true;
        }

        // Move bubble to ring
        function moveBubbleToRing(bubble, ringName) {
            const radius = ringRadii[ringName];
            const angle = bubble.userData.angle;
            bubble.userData.currentRing = ringName;
            bubble.userData.points = ringPoints[ringName];
            bubble.userData.targetPosition = {
                x: Math.cos(angle) * radius,
                y: Math.sin(angle) * radius,
                z: 0
            };

            // Update status label with current spectrum text
            const statusText = bubble.userData.spectrum[ringName];
            updateStatusLabel(bubble, statusText);

            updateScore();
            if (lockedBubble === bubble) {
                updateInfoPanel(bubble);
            }
        }

        // Update info panel
        function updateInfoPanel(bubble) {
            const panel = document.getElementById('info-panel');
            const data = bubble.userData;

            document.getElementById('panel-title').textContent = data.name;
            const categoryBadge = document.getElementById('panel-category');
            categoryBadge.textContent = data.category;
            categoryBadge.style.backgroundColor = getCategoryColor(data.category);
            document.getElementById('panel-description').textContent = data.description;

            const ukLawDiv = document.getElementById('panel-uk-law');
            ukLawDiv.className = `uk-law ${data.ukLaw.status}`;
            const icons = { 'protected': '✓', 'partial': '◐', 'not-protected': '✗' };
            document.getElementById('uk-law-icon').textContent = icons[data.ukLaw.status];
            document.getElementById('uk-law-title').textContent = data.ukLaw.title;
            document.getElementById('uk-law-text').textContent = data.ukLaw.text;

            const spectrumItems = document.getElementById('spectrum-items');
            spectrumItems.innerHTML = `
                <div class="spectrum-item outer ${data.currentRing === 'outer' ? 'selected' : ''}" data-ring="outer">
                    <div style="font-weight: 600; margin-bottom: 4px;">1 point</div>
                    ${data.spectrum.outer}
                </div>
                <div class="spectrum-item middle ${data.currentRing === 'middle' ? 'selected' : ''}" data-ring="middle">
                    <div style="font-weight: 600; margin-bottom: 4px;">2 points</div>
                    ${data.spectrum.middle}
                </div>
                <div class="spectrum-item inner ${data.currentRing === 'inner' ? 'selected' : ''}" data-ring="inner">
                    <div style="font-weight: 600; margin-bottom: 4px;">3 points</div>
                    ${data.spectrum.inner}
                </div>
            `;

            // Add click handlers to spectrum items
            spectrumItems.querySelectorAll('.spectrum-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const ring = item.dataset.ring;
                    moveBubbleToRing(bubble, ring);
                });
            });

            // Update navigation counter
            const currentIndex = bubbles.indexOf(bubble);
            document.getElementById('nav-counter').textContent = `${currentIndex + 1} / ${bubbles.length}`;

            panel.classList.add('visible');

            // Move wheel up on mobile so it's not hidden by panel
            if (window.innerWidth <= 768) {
                scene.position.y = CFG.MOBILE_PANEL_OFFSET_Y;
            }
        }

        function hideInfoPanel() {
            document.getElementById('info-panel').classList.remove('visible');
            // Reset camera position on mobile when panel hides
            if (window.innerWidth <= 768) {
                scene.position.y = 0;
            }
        }

        // Navigation button handlers
        function navigateToBubble(direction) {
            if (!lockedBubble) return;
            const currentIndex = bubbles.indexOf(lockedBubble);
            let newIndex = currentIndex + direction;
            // Wrap around
            if (newIndex < 0) newIndex = bubbles.length - 1;
            if (newIndex >= bubbles.length) newIndex = 0;
            lockedBubble = bubbles[newIndex];
            updateInfoPanel(lockedBubble);
        }

        document.getElementById('prev-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            navigateToBubble(-1);
        });

        document.getElementById('next-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            navigateToBubble(1);
        });

        // Mouse events
        container.addEventListener('mousedown', (e) => {
            previousMousePosition = { x: e.clientX, y: e.clientY };

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(bubbles);

            if (intersects.length > 0) {
                isDraggingBubble = true;
                draggedBubble = intersects[0].object;
                draggedBubble.userData.targetScale = CFG.DRAG_SCALE;

                // Calculate offset: difference between click position radius and bubble radius
                const vector = new THREE.Vector3(mouse.x, mouse.y, CFG.PROJECTION_Z);
                vector.unproject(camera);
                const dir = vector.sub(camera.position).normalize();
                const distance = -camera.position.z / dir.z;
                const clickPos = camera.position.clone().add(dir.multiplyScalar(distance));
                const clickRadius = Math.sqrt(clickPos.x * clickPos.x + clickPos.y * clickPos.y);
                const bubbleRadius = Math.sqrt(draggedBubble.position.x * draggedBubble.position.x + draggedBubble.position.y * draggedBubble.position.y);
                dragRadiusOffset = bubbleRadius - clickRadius;
            } else {
                isDragging = true;
            }
        });

        container.addEventListener('mouseup', (e) => {
            if (isDraggingBubble && draggedBubble) {
                // Determine which ring to snap to based on distance from center
                const pos = draggedBubble.position;
                const dist = Math.sqrt(pos.x * pos.x + pos.y * pos.y);

                let targetRing = 'inner';
                if (dist > (ringRadii.inner + ringRadii.middle) / 2) {
                    if (dist > (ringRadii.middle + ringRadii.outer) / 2) {
                        targetRing = 'outer';
                    } else {
                        targetRing = 'middle';
                    }
                }

                moveBubbleToRing(draggedBubble, targetRing);
                draggedBubble.userData.targetScale = 1;
                draggedBubble = null;
            }
            isDragging = false;
            isDraggingBubble = false;
        });

        container.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            if (isDraggingBubble && draggedBubble) {
                // Convert mouse to 3D position on XY plane
                const vector = new THREE.Vector3(mouse.x, mouse.y, CFG.PROJECTION_Z);
                vector.unproject(camera);
                const dir = vector.sub(camera.position).normalize();
                const distance = -camera.position.z / dir.z;
                const pos = camera.position.clone().add(dir.multiplyScalar(distance));

                // Keep bubble at its angle, just change radius
                // Apply offset so bubble doesn't jump to cursor
                const currentDist = Math.sqrt(pos.x * pos.x + pos.y * pos.y) + dragRadiusOffset;
                const clampedDist = Math.max(ringRadii.inner - CFG.RING_PADDING, Math.min(ringRadii.outer + CFG.RING_PADDING, currentDist));
                const angle = draggedBubble.userData.angle;

                draggedBubble.position.x = Math.cos(angle) * clampedDist;
                draggedBubble.position.y = Math.sin(angle) * clampedDist;
            } else if (isDragging) {
                const deltaMove = {
                    x: e.clientX - previousMousePosition.x,
                    y: e.clientY - previousMousePosition.y
                };
                rotationVelocity.x = deltaMove.y * CFG.ROTATION_SENSITIVITY;
                rotationVelocity.y = deltaMove.x * CFG.ROTATION_SENSITIVITY;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        container.addEventListener('click', (e) => {
            if (isDraggingBubble) return; // Don't trigger click after drag

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(bubbles);

            if (intersects.length > 0) {
                const clickedBubble = intersects[0].object;
                if (lockedBubble === clickedBubble) {
                    lockedBubble = null;
                    hideInfoPanel();
                    // Restore opacity to deselected state if applicable
                    clickedBubble.userData.targetOpacity = clickedBubble.userData.isDeselected ? CFG.DESELECTED_OPACITY : CFG.ACTIVE_OPACITY;
                } else {
                    lockedBubble = clickedBubble;
                    updateInfoPanel(clickedBubble);
                    // Set full opacity for selected bubble
                    clickedBubble.userData.targetOpacity = CFG.SELECTED_OPACITY;
                }
            } else {
                lockedBubble = null;
                hideInfoPanel();
            }
        });

        container.addEventListener('wheel', (e) => {
            camera.position.z += e.deltaY * CFG.ZOOM_SENSITIVITY;
            camera.position.z = Math.max(CFG.CAMERA_Z_MIN, Math.min(CFG.CAMERA_Z_MAX, camera.position.z));
        });

        // Touch event handlers for mobile
        let touchStartDistance = 0;
        let touchStartPosition = { x: 0, y: 0 };
        let isTouchDragging = false;
        let isTouchDraggingBubble = false;
        let touchDraggedBubble = null;
        let touchDragRadiusOffset = 0;

        function getTouchDistance(touches) {
            if (touches.length < 2) return 0;
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getTouchCenter(touches) {
            if (touches.length < 2) {
                return { x: touches[0].clientX, y: touches[0].clientY };
            }
            return {
                x: (touches[0].clientX + touches[1].clientX) / 2,
                y: (touches[0].clientY + touches[1].clientY) / 2
            };
        }

        container.addEventListener('touchstart', (e) => {
            // Don't prevent default for elements that need it (category buttons etc)
            if (e.target !== renderer.domElement) return;

            e.preventDefault();

            const touch = e.touches[0];
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

            touchStartPosition = { x: touch.clientX, y: touch.clientY };

            if (e.touches.length === 2) {
                // Pinch zoom start
                touchStartDistance = getTouchDistance(e.touches);
            } else {
                // Single finger - check for bubble drag or rotation
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(bubbles);

                if (intersects.length > 0) {
                    isTouchDraggingBubble = true;
                    touchDraggedBubble = intersects[0].object;
                    touchDraggedBubble.userData.targetScale = CFG.DRAG_SCALE;

                    // Calculate offset
                    const vector = new THREE.Vector3(mouse.x, mouse.y, CFG.PROJECTION_Z);
                    vector.unproject(camera);
                    const dir = vector.sub(camera.position).normalize();
                    const distance = -camera.position.z / dir.z;
                    const clickPos = camera.position.clone().add(dir.multiplyScalar(distance));
                    const clickRadius = Math.sqrt(clickPos.x * clickPos.x + clickPos.y * clickPos.y);
                    const bubbleRadius = Math.sqrt(touchDraggedBubble.position.x * touchDraggedBubble.position.x + touchDraggedBubble.position.y * touchDraggedBubble.position.y);
                    touchDragRadiusOffset = bubbleRadius - clickRadius;
                } else {
                    isTouchDragging = true;
                }
            }
        }, { passive: false });

        container.addEventListener('touchmove', (e) => {
            if (e.target !== renderer.domElement) return;
            e.preventDefault();

            if (e.touches.length === 2) {
                // Pinch zoom
                const newDistance = getTouchDistance(e.touches);
                if (touchStartDistance > 0) {
                    const delta = touchStartDistance - newDistance;
                    camera.position.z += delta * CFG.TOUCH_ZOOM_SENSITIVITY;
                    camera.position.z = Math.max(CFG.CAMERA_Z_MIN, Math.min(CFG.CAMERA_Z_MAX, camera.position.z));
                }
                touchStartDistance = newDistance;
            } else if (e.touches.length === 1) {
                const touch = e.touches[0];
                mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

                if (isTouchDraggingBubble && touchDraggedBubble) {
                    // Drag bubble between rings
                    const vector = new THREE.Vector3(mouse.x, mouse.y, CFG.PROJECTION_Z);
                    vector.unproject(camera);
                    const dir = vector.sub(camera.position).normalize();
                    const distance = -camera.position.z / dir.z;
                    const pos = camera.position.clone().add(dir.multiplyScalar(distance));

                    const currentDist = Math.sqrt(pos.x * pos.x + pos.y * pos.y) + touchDragRadiusOffset;
                    const clampedDist = Math.max(ringRadii.inner - CFG.RING_PADDING, Math.min(ringRadii.outer + CFG.RING_PADDING, currentDist));
                    const angle = touchDraggedBubble.userData.angle;

                    touchDraggedBubble.position.x = Math.cos(angle) * clampedDist;
                    touchDraggedBubble.position.y = Math.sin(angle) * clampedDist;
                } else if (isTouchDragging) {
                    // Rotate wheel
                    const deltaMove = {
                        x: touch.clientX - touchStartPosition.x,
                        y: touch.clientY - touchStartPosition.y
                    };
                    rotationVelocity.x = deltaMove.y * CFG.TOUCH_ROTATION_SENSITIVITY;
                    rotationVelocity.y = deltaMove.x * CFG.TOUCH_ROTATION_SENSITIVITY;
                    touchStartPosition = { x: touch.clientX, y: touch.clientY };
                }
            }
        }, { passive: false });

        container.addEventListener('touchend', (e) => {
            if (isTouchDraggingBubble && touchDraggedBubble) {
                // Snap bubble to nearest ring
                const pos = touchDraggedBubble.position;
                const dist = Math.sqrt(pos.x * pos.x + pos.y * pos.y);

                let targetRing = 'inner';
                if (dist > (ringRadii.inner + ringRadii.middle) / 2) {
                    if (dist > (ringRadii.middle + ringRadii.outer) / 2) {
                        targetRing = 'outer';
                    } else {
                        targetRing = 'middle';
                    }
                }

                moveBubbleToRing(touchDraggedBubble, targetRing);
                touchDraggedBubble.userData.targetScale = CFG.DEFAULT_SCALE;

                // If it was a tap (not much movement), select the bubble
                if (e.changedTouches.length > 0) {
                    const touch = e.changedTouches[0];
                    const dx = Math.abs(touch.clientX - touchStartPosition.x);
                    const dy = Math.abs(touch.clientY - touchStartPosition.y);
                    if (dx < 10 && dy < 10) {
                        // It was a tap
                        if (lockedBubble === touchDraggedBubble) {
                            lockedBubble = null;
                            hideInfoPanel();
                        } else {
                            lockedBubble = touchDraggedBubble;
                            updateInfoPanel(touchDraggedBubble);
                        }
                    }
                }

                touchDraggedBubble = null;
            } else if (isTouchDragging && e.changedTouches.length > 0) {
                // Check if it was a tap to deselect
                const touch = e.changedTouches[0];
                const dx = Math.abs(touch.clientX - touchStartPosition.x);
                const dy = Math.abs(touch.clientY - touchStartPosition.y);
                if (dx < 10 && dy < 10 && lockedBubble) {
                    // Check if tap was on a bubble
                    mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(bubbles);

                    if (intersects.length === 0) {
                        lockedBubble = null;
                        hideInfoPanel();
                    }
                }
            }

            isTouchDragging = false;
            isTouchDraggingBubble = false;
            touchStartDistance = 0;
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);


            
            // Rotation
            scene.rotation.z -= rotationVelocity.y;
            scene.rotation.x += rotationVelocity.x;
            rotationVelocity.x *= 0.95;
            rotationVelocity.y *= 0.95;

            if (!isDragging && !isDraggingBubble && !lockedBubble &&
                Math.abs(rotationVelocity.x) < CFG.AUTO_ROTATE_THRESHOLD && Math.abs(rotationVelocity.y) < CFG.AUTO_ROTATE_THRESHOLD) {
                scene.rotation.z += CFG.AUTO_ROTATE_AMOUNT;
            }

            // Hover detection
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(bubbles);

            // Reset all bubbles (but keep locked bubble highlighted and deselected state)
            bubbles.forEach(bubble => {
                if (bubble === lockedBubble) {
                    bubble.userData.targetScale = CFG.SELECTED_SCALE;
                    bubble.userData.targetOpacity = CFG.SELECTED_OPACITY;
                    if (bubble.userData.glow) bubble.userData.glow.material.opacity = CFG.GLOW_HIGHLIGHT_OPACITY;
                } else if (bubble === draggedBubble) {
                    // Keep drag scale
                } else {
                    // Preserve deselected state, otherwise reset to normal size and opacity
                    bubble.userData.targetScale = bubble.userData.isDeselected ? CFG.DESELECTED_SCALE : CFG.DEFAULT_SCALE;
                    bubble.userData.targetOpacity = bubble.userData.isDeselected ? CFG.DESELECTED_OPACITY : CFG.ACTIVE_OPACITY;
                    if (bubble.userData.glow) bubble.userData.glow.material.opacity = CFG.GLOW_OPACITY;
                }
            });

            // Only update hover state if not locked
            if (!lockedBubble && !isDraggingBubble) {
                if (intersects.length > 0) {
                    const bubble = intersects[0].object;
                    bubble.userData.targetScale = 1.2;
                    if (bubble.userData.glow) bubble.userData.glow.material.opacity = 0.4;
                    if (hoveredBubble !== bubble) {
                        hoveredBubble = bubble;
                    }
                    document.body.style.cursor = 'pointer';
                } else {
                    hoveredBubble = null;
                    document.body.style.cursor = isDragging ? 'grabbing' : 'grab';
                }
            } else {
                document.body.style.cursor = intersects.length > 0 ? 'pointer' : (isDragging ? 'grabbing' : 'grab');
            }

            // Animate bubbles
            bubbles.forEach((bubble, index) => {
                // Scale animation
                const currentScale = bubble.scale.x;
                const targetScale = bubble.userData.targetScale;
                const newScale = currentScale + (targetScale - currentScale) * CFG.LERP;
                bubble.scale.set(newScale, newScale, newScale);

                // Opacity animation
                const currentOpacity = bubble.material.opacity;
                const targetOpacity = bubble.userData.targetOpacity;
                const newOpacity = currentOpacity + (targetOpacity - currentOpacity) * CFG.LERP;
                bubble.material.opacity = newOpacity;

                // Apply opacity to label sprites as well
                bubble.userData.label.material.opacity = newOpacity;
                bubble.userData.statusLabel.material.opacity = newOpacity;

                // Position animation (snap to ring)
                if (!isDraggingBubble || bubble !== draggedBubble) {
                    const target = bubble.userData.targetPosition;
                    bubble.position.x += (target.x - bubble.position.x) * CFG.LERP;
                    bubble.position.y += (target.y - bubble.position.y) * CFG.LERP;
                    bubble.position.z += (target.z - bubble.position.z) * CFG.LERP;
                }

                // Subtle floating
                const time = Date.now() * CFG.FLOAT_SPEED;
                bubble.position.z = Math.sin(time + index) * CFG.FLOAT_AMPLITUDE;

                // Make labels face camera and keep in fixed position
                if (bubble.userData.label) {
                    bubble.userData.label.quaternion.copy(camera.quaternion);
                    const lp = bubble.userData.labelLocalPos;
                    bubble.userData.label.position.set(lp.x, lp.y, lp.z);
                }
                if (bubble.userData.statusLabel) {
                    bubble.userData.statusLabel.quaternion.copy(camera.quaternion);
                    const sp = bubble.userData.statusLabelLocalPos;
                    bubble.userData.statusLabel.position.set(sp.x, sp.y, sp.z);
                }
            });

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.position.z = getOptimalCameraZ();
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // localStorage persistence
        const STORAGE_KEY = 'wheelOfPrivilege_selections';

        function saveSelections() {
            const selections = {};
            bubbles.forEach(b => {
                selections[b.userData.name] = b.userData.currentRing;
            });
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(selections));
            } catch (e) {
                console.warn('Could not save to localStorage:', e);
            }
        }

        function loadSelections() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    const selections = JSON.parse(saved);
                    bubbles.forEach(b => {
                        const ring = selections[b.userData.name];
                        if (ring && ['inner', 'middle', 'outer'].includes(ring)) {
                            moveBubbleToRing(b, ring);
                        }
                    });
                }
            } catch (e) {
                console.warn('Could not load from localStorage:', e);
            }
        }

        // URL hash encoding for shareable links
        const ringToChar = { inner: 'i', middle: 'm', outer: 'o' };
        const charToRing = { 'i': 'inner', 'm': 'middle', 'o': 'outer' };
        const stateToChar = { active: 'i', inactive: 'o' };
        const charToState = { 'i': 'active', 'o': 'inactive' };

        function getSelectionsHash() {
            // Create bubble hash: one char per bubble in order
            const bubbleHash = bubbles.map(b => ringToChar[b.userData.currentRing]).join('');
            
            // Create category hash: one char per category in order
            const categoryOrder = Object.keys(categories);
            const categoryHash = categoryOrder.map(catName => {
                const btn = categoryButtons[catName];
                const isActive = btn.classList.contains('active');
                return isActive ? 'i' : 'o';
            }).join('');
            
            // Return combined hash with separator: bubbles/categories
            return bubbleHash + '/' + categoryHash;
        }

        function updateUrlHash() {
            const hash = getSelectionsHash();
            history.replaceState(null, '', '#' + hash);
        }

        function loadFromUrlHash() {
            const hash = window.location.hash.slice(1); // Remove '#'
            if (!hash) return false;
            
            const parts = hash.split('/');
            if (parts.length !== 2) return false; // Must have both bubble and category parts
            
            const [bubbleHash, categoryHash] = parts;
            
            // Validate and load bubble selections
            if (bubbleHash.length === bubbles.length) {
                let valid = true;
                for (let i = 0; i < bubbleHash.length; i++) {
                    if (!charToRing[bubbleHash[i]]) {
                        valid = false;
                        break;
                    }
                }
                if (valid) {
                    bubbles.forEach((b, i) => {
                        const ring = charToRing[bubbleHash[i]];
                        if (ring) {
                            // Use original to avoid recursive hash updates
                            originalMoveBubbleToRing(b, ring);
                        }
                    });
                } else {
                    return false;
                }
            } else {
                return false;
            }
            
            // Validate and load category selections
            const categoryOrder = Object.keys(categories);
            if (categoryHash.length === categoryOrder.length) {
                let valid = true;
                for (let i = 0; i < categoryHash.length; i++) {
                    if (!charToState[categoryHash[i]]) {
                        valid = false;
                        break;
                    }
                }
                if (valid) {
                    categoryOrder.forEach((catName, i) => {
                        const btn = categoryButtons[catName];
                        const shouldBeActive = charToState[categoryHash[i]] === 'active';
                        const isCurrentlyActive = btn.classList.contains('active');
                        
                        // Toggle if state differs from current
                        if (shouldBeActive !== isCurrentlyActive) {
                            btn.classList.toggle('active');
                            const isActive = btn.classList.contains('active');
                            
                            // Update all bubbles in this category
                            bubbles.forEach(bubble => {
                                if (bubble.userData.category === catName) {
                                    bubble.userData.isDeselected = !isActive;
                                    bubble.userData.targetOpacity = isActive ? CFG.ACTIVE_OPACITY : CFG.DESELECTED_OPACITY;
                                    bubble.userData.targetScale = isActive ? CFG.DEFAULT_SCALE : CFG.DESELECTED_SCALE;
                                }
                            });
                        }
                    });
                    return true; // Successfully loaded from hash
                }
            }
            return false; // No valid hash
        }

        // Update moveBubbleToRing to save after each change
        const originalMoveBubbleToRing = moveBubbleToRing;
        moveBubbleToRing = function(bubble, ringName) {
            originalMoveBubbleToRing(bubble, ringName);
            saveSelections();
            updateUrlHash();
        };

        // Initialize - URL hash takes priority over localStorage
        if (!loadFromUrlHash()) {
            loadSelections();
        }
        updateScore();
        updateUrlHash(); // Set initial hash
        animate();
    </script>
</body>
</html>
